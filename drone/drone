#!/usr/bin/python

CONFIG_FILE = "/etc/soton/drone.conf"
BASE_DIR    = "/etc/soton"
VERSION     = "2017-02-07-01"

import os
import sys
import argparse
import subprocess
import ConfigParser
import datetime
import requests
import re
import platform
import getpass
import time
import json
import yaml

class DroneAgent:

	################################################################################

	def fatal(self,code,message):
		sys.stderr.write("Error: " + message + "\n")
		sys.exit(code)

	def fatalex(self,code,message,exception):
		sys.stderr.write("Error: " + message + " - " + str(type(exception)) + " " + str(exception) + "\n")
		sys.exit(code)

	################################################################################

	def warn(self,message):
		sys.stderr.write("Warning: " + message + "\n")

	def warnex(self,message,exception):
		sys.stderr.write("Warning: " + message + " - " + str(type(exception)) + " " + str(exception) + "\n")

	################################################################################

	def strtime(self,when=None):
		if when is None:
			dt = datetime.datetime.utcnow()
		else:
			dt = datetime.datetime.utcfromtimestamp(int(when))

		return dt.strftime("%Y-%m-%d %H:%M:%S")

	################################################################################

	def get_config(self):
		self.config = ConfigParser.RawConfigParser()

		## Set up default sections
		self.config.add_section('backup')
		self.config.add_section('puppet')
		self.config.add_section('server')
		self.config.add_section('ssh')
		self.config.add_section('reskit')
		self.config.add_section('csw')
		self.config.add_section('update')
	
		## Set up default values
		self.config.set('backup','user','backup')
		self.config.set('backup','server','localhost')
		self.config.set('backup','rsyncd_port','873')
		self.config.set('backup','port','9999')
		self.config.set('backup','vgname','sysvg')
		self.config.set('backup','lv_source_name','home')
		self.config.set('backup','lv_snap_name','homesnap')
		self.config.set('backup','lv_snap_mount','/mnt/homesnap')

		self.config.set('puppet','user','puppet')
		self.config.set('puppet','binary','/opt/puppetlabs/bin/puppet')
		self.config.set('puppet','server','localhost')

		self.config.set('reskit','pkgdir','/etc/reskit/packages/')
		self.config.set('reskit','server','localhost')
		self.config.set('reskit','share','reskit')

		self.config.set('csw','server','localhost')

		self.config.set('update','pkcon_binary','/bin/pkcon')

		self.config.set('ssh','binary','/usr/bin/ssh')

		self.config.set('server','api_key','unset')

		try:
			self.config.read(CONFIG_FILE)
		except Exception as ex:
			self.fatalex(2,"Could not read the config file " + CONFIG_FILE,ex)

	################################################################################

	def sysexec(self,command,shell=False):
		if self.debug:
			if type(command) is list:
				print "Executing command " + str(" ".join(command))
			else:
				print "Executing command " + str(command)

		try:
			proc = subprocess.Popen(command,stdout=subprocess.PIPE, stderr=subprocess.STDOUT,shell=shell)
			(stdoutdata, stderrdata) = proc.communicate()
			if stdoutdata is None:
				stdoutdata = ""

			if self.debug:
				print "return code: " + str(proc.returncode)
				print "---"
				print stdoutdata
				print "---"
			
			return (proc.returncode,str(stdoutdata))
		except Exception as ex:
			return (1,str(type(ex)) + " " + str(ex))

	################################################################################

	def is_network_up(self,timeout=30,exit_if_down=False):
		if self.args.nmignore:
			if self.debug: print "skipping network test because -i was specified"
			return True

		if self.verbose: print "checking network status"

		(code,output) = self.sysexec(["/usr/bin/nm-online","-q","--timeout=" + str(timeout)])
	
		if code == 0:
			if self.verbose: print "network manager reports the network is up"
			return True
		else:
			if exit_if_down:
				if self.verbose: print "network manager reports the network is down, exiting"
				sys.exit(254)
			else:
				if self.verbose: print "network manager reports the network is down"
				return False

	################################################################################
	################################################################################

	def puppet_sync(self):
		self.is_network_up(exit_if_down=True)

		if self.verbose: print "starting sync"

		(code, output) = self.sysexec("""/usr/bin/rsync -e "ssh -i %s/ssh_private_key -o PreferredAuthentications=publickey -oStrictHostKeyChecking=no" -av --delete %s@%s: %s/puppet/""" % (BASE_DIR, self.config.get('puppet','user'),self.config.get('puppet','server'),BASE_DIR),shell=True)

		if code != 0:
			self.fatal(3,"sync failed: \n" + output)
		else:
			if self.verbose: print "sync complete"

	################################################################################

	def puppet_apply(self):
		if self.verbose: print "starting puppet apply"

		(code, output) = self.sysexec("""%s apply --detailed-exitcodes --modulepath %s/puppet/modules/ %s/puppet/manifests/site.pp""" % (self.config.get('puppet','binary'),BASE_DIR,BASE_DIR),shell=True)

		uts = int(time.time())
		when = "puppet apply last ran at " + self.strtime() + "\n"

		if code == 0:
			status = "system complies with policy, no changes were required"
			if self.verbose: print status
		elif code == 2:
			status = "system complies with policy, changes made to system:"
			status = status + "\n" + output
			if self.verbose: print status

		else:
			status = "apply failed: \n" + output
			self.puppet_save_state(uts,code,output)
			self.fatal(4,status)

		self.puppet_save_state(uts,code,output)

	################################################################################

	def puppet_save_state(self,uts,code,output):
		data = {'when': uts, 'code': code, 'output': output}

		try:
			if not os.path.exists(BASE_DIR + "/state"):
				os.mkdir(BASE_DIR + "/state")
		except Exception as ex:
			self.warn("Could not create directory " + BASE_DIR + "/state - unable to save puppet status")
			return

		try:
			with open(BASE_DIR + "/state/puppet","w") as fp:
				json.dump(data,fp)
		except Exception as ex:
			self.warnex("Could not write to " + BASE_DIR + "/state/puppet",ex)

	################################################################################

	def puppet_get_state(self):
		status_file = BASE_DIR + "/state/puppet" 

		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					data = json.load(fp)
			except Exception as ex:
				self.fatalex(5,"Could not read from puppet status file " + status_file,ex)

			try:
				print "the last puppet apply finished at " + self.strtime(data['when'])

				if data['code'] == 0:
					print "system was in compliance with the system policy"
				elif data['code'] == 2:
					print "changes were made to the system to comply with the system policy:"
					print data['output'].rstrip("\n")
				else:
					print "the attempt to apply the system policy failed:"
					print data['output'].rstrip("\n")

			except Exception as ex:
				self.fatalex(30,"Could not load puppet status",ex)

		else:
			print "puppet apply has never been run on this system"

	################################################################################

	def puppet_facts(self):

		(code, output) = self.sysexec("""%s facts find --modulepath %s/puppet/modules/""" % (self.config.get('puppet','binary'),BASE_DIR),shell=True)

		if code == 0:
			print output
		else:
			self.fatal(27,"Could not retrieve facts: \n" + output)

	################################################################################

	def puppet(self):
		if self.action == 'sync':
			self.puppet_sync()

		elif self.action == "apply":
			self.puppet_apply()

		elif self.action == "run":
			self.puppet_sync()
			self.puppet_apply()

		elif self.action == "status":
			self.puppet_get_state()

		elif self.action == "facts":
			self.puppet_facts()

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	################################################################################
	################################################################################

	def backup_now(self):
		if not self.is_network_up():
			self.backup_save_state(uts,-2,"The network is down, cannot run backup")
			if self.verbose: print "network is down, not running backup"

		if self.verbose: print "starting backup (this may take several minutes)"

		uts = int(time.time())
		## Ensure the mount point for the snapshot exists
		if self.debug: print "checking config.backup.lv_snap_mount path"
		if not os.path.exists(self.config.get('backup','lv_snap_mount')):
			self.backup_save_state(uts,-1,"The lv_snap_mount directory does not exist")
			self.fatal(20,"The lv_snap_mount directory - " + self.config.get('backup','lv_snap_mount') + " - does not exist")

		## Create the snapshot of home
		if self.debug: print "creating snapshot"
		(code, output) = self.sysexec("""/sbin/lvcreate -n %s -kn -s %s/%s""" % (self.config.get('backup','lv_snap_name'), self.config.get('backup','vgname'), self.config.get('backup','lv_source_name'),),shell=True)

		if code == 0:
			if self.verbose: print "snapshot created"
		else:
			self.backup_save_state(uts,-1,"Could not create disk snapshot: \n" + output)
			self.fatal(21,"Could not create snapshot:\n" + output)

		## Mount it
		if self.debug: print "mounting snapshot"
		(code, output) = self.sysexec("""/bin/mount -o ro,nouuid /dev/mapper/%s-%s %s""" % (self.config.get('backup','vgname'), self.config.get('backup','lv_snap_name'), self.config.get('backup','lv_snap_mount'),),shell=True)

		if code == 0:
			if self.verbose: print "snapshot mounted"
		else:
			self.backup_save_state(uts,-1,"Could not mount disk snapshot: \n" + output)
			self.fatal(21,"Could not mount snapshot:\n" + output)

		## k we're ready! start the backup!
		uts = int(time.time())
		(code, output) = self.sysexec("""%s %s@%s -i %s/ssh_private_key -o "ExitOnForwardFailure yes" -R %s:localhost:%s """ % (self.config.get('ssh','binary'), self.config.get('backup','user'), self.config.get('backup','server'), BASE_DIR, self.config.get('backup','port'),self.config.get('backup','rsyncd_port'),),shell=True)

		fail = False
		if code == 0:
			status = "backup complete, all files backed up"
			self.backup_save_state(uts,code)
		elif code == 1:
			status = "backup partially complete, some files did not backup"
			self.backup_save_state(uts,code)
		else:
			fail = True # we use this later to exit with an error
			status = "backup failed"
			self.backup_save_state(uts,code,output)

		if self.verbose: print status

		if self.debug: print "unmounting snapshot"
		## Now we umount the snapshot and delete it as we don't need it anymore
		(code, output) = self.sysexec("""/bin/umount %s""" % (self.config.get('backup','lv_snap_mount'),),shell=True)

		if code == 0:
			if self.verbose: print "snapshot unmounted"
		else:
			self.fatal(22,"Could not unmount snapshot:\n" + output)

		## Create the snapshot of home
		if self.debug: print "removing snapshot"
		(code, output) = self.sysexec("""/sbin/lvremove -f %s/%s""" % (self.config.get('backup','vgname'), self.config.get('backup','lv_snap_name'),),shell=True)

		if code == 0:
			if self.verbose: print "snapshot removed"
		else:
			self.fatal(23,"Could not delete snapshot:\n" + output)

		# fatal exit if the backup failed
		if fail:
			self.fatal(24,status)

	################################################################################

	def backup_save_state(self,uts,code,output=None):
		data = {'when': uts, 'code': code, 'output': output}

		try:
			if not os.path.exists(BASE_DIR + "/state"):
				os.mkdir(BASE_DIR + "/state")
		except Exception as ex:
			self.warn("Could not create directory " + BASE_DIR + "/state - unable to save backup status")
			return

		try:
			with open(BASE_DIR + "/state/backup","w") as fp:
				json.dump(data,fp)
		except Exception as ex:
			self.warnex("Could not write to " + BASE_DIR + "/state/backup",ex)

	################################################################################

	def backup_load_state(self):
		status_file = BASE_DIR + "/state/backup" 

		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					data = json.load(fp)
			except Exception as ex:
				self.fatalex(5,"Could not read from backup status file " + status_file,ex)

			try:
				code = data['code']
				when = data['when']
				if 'output' in data:
					output = data['output']
				else:
					output = None
			except Exception as ex:
				self.fatalex(29,"Could not load backup status",ex)

		else:
			code   = None
			when   = None
			output = None

		return (code,when,output)

	################################################################################

	def backup_get_state(self):

		(code,when,output) = self.backup_load_state()

		if code is not None:

			print "the last backup attempt was made at " + self.strtime(when)

			if code == 0:
				print "the last backup competed successfully, all files were backed up"
			elif code == 1:
				print "the last backup completed but some files could not be backed up"
			else:
				print "the last backup failed"
				if output is not None:
					print output
		else:
			print "a backup has never been run on this system"

	################################################################################

	def backup_ifneeded(self):
		if self.debug: print "checking for last backup"
		(code,when,output) = self.backup_load_state()

		if code is None:
			if self.verbose: print "no backup status found, triggering backup"
			self.backup_now()
		else:
			last = datetime.datetime.utcfromtimestamp(int(when))

			if (datetime.datetime.utcnow() - last) > datetime.timedelta(hours=12):
				if self.verbose: print "backup is required, triggering backup"
				self.backup_now()
			else:
				if self.verbose: print "backup is not required"

	################################################################################

	def backup(self):
		if self.action == 'now':
			self.backup_now()

		elif self.action == "status":
			self.backup_get_state()

		elif self.action == "ifneeded":
			self.backup_ifneeded()

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	################################################################################
	################################################################################

	def update_trigger(self):


		if self.verbose: print "downloading package updates"
		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "--only-download", "update"])

		if code == 0:
			if self.verbose: print "package updates downloaded"
		else:
			self.fatal(28,"Could not download package updates:\n" + output)

		if not os.path.exists("/system-update"):
			if self.debug: print "the /system-update trigger is absent"
			if self.verbose: print "triggering offline update"
			(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-trigger"])

			if code == 0:
				if self.verbose: print "the system will update at the next reboot"
			else:
				self.fatal(29,"Could not trigger the offline update:\n" + output)
		else:
			if self.debug: print "the /system-update trigger is already present"
			if self.verbose: print "the system will update at the next reboot"

	################################################################################

	def update_status(self):

		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-get-prepared"])
		print output.rstrip("\n")

	################################################################################

	def update_history(self):

		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-status"])
		print output.rstrip("\n")

	################################################################################

	def update(self):
		if self.action == 'status':
			self.update_status()

		elif self.action == 'history':
			self.update_history()

		elif self.action == "trigger":
			self.update_trigger()

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	################################################################################
	################################################################################

	def reskit_update_package(self,package):
		if self.verbose: print "starting update of '" + package + "'"

		reskit_pkgdir  = self.config.get('reskit','pkgdir')
		reskit_server  = self.config.get('reskit','server')
		reskit_share   = self.config.get('reskit','share')

		package_file = os.path.join(reskit_pkgdir,package)

		## Open the reskit package file
		## this is a yaml formatted file with
		## two variables - source and dest (for rsync)
		try:
			if self.debug: print "opening file '" + package_file + "'"
			with open(package_file,"r") as fp:
				package_data = yaml.safe_load(fp)
		except Exception as ex:
			if self.verbose: self.warnex("Could not read package metadata from '" + package_file + "'",ex)
			return

		try:
			package_source = package_data['src']
			package_dest   = package_data['dest']
		except Exception as ex:
			if self.verbose: self.warnex("Invalid/incorrect metadata in '" + package_file + "'",ex)
			return

		(code, output) = self.sysexec("""/usr/bin/rsync -av --delete rsync://%s/%s/%s %s""" % (reskit_server, reskit_share, package_source, package_dest,),shell=True)

		if code != 0:
			if self.verbose: print "reskit update of '" + package + "' failed: \n" + output 
		else:
			if self.verbose: print "reskit update of '" + package + "' complete"

	################################################################################

	def reskit_update(self):
		self.is_network_up(exit_if_down=True)

		if self.verbose: print "starting reskit update (this may take several minutes)"

		reskit_pkg_dir = self.config.get('reskit','pkgdir')

		if self.debug: print "checking config.reskit.pkgdir"
		if not os.path.exists(reskit_pkg_dir):
			self.fatal(25,"The reskit pkgdir directory - " + reskit_pkg_dir + " - does not exist")
		if not os.path.isdir(reskit_pkg_dir):
			self.fatal(26,"The reskit pkgdir path - " + reskit_pkg_dir + " - is not a directory")

		reskit_files = [f for f in os.listdir(reskit_pkg_dir) if os.path.isfile(os.path.join(reskit_pkg_dir, f))]

		package_name = self.args.subaction
		if package_name is None:
			for f in reskit_files:
				try:
					self.reskit_update_package(f)
				except Exception as ex:
					if self.verbose: self.warnex("Failed to run reskit update on " + f,ex)
		else:
			if self.debug: print "user asked to update specific package '" + package_name + "'"

			if package_name in reskit_files:
				self.reskit_update_package(package_name)
			else:
				self.fatal(31,"Package '" + package_name + "' not found")

		if self.verbose: print "reskit update complete"

	################################################################################

	def reskit_list(self):
		reskit_pkg_dir = self.config.get('reskit','pkgdir')

		if self.debug: print "checking config.reskit.pkgdir"
		if not os.path.exists(reskit_pkg_dir):
			self.fatal(25,"The reskit pkgdir directory - " + reskit_pkg_dir + " - does not exist")
		if not os.path.isdir(reskit_pkg_dir):
			self.fatal(26,"The reskit pkgdir path - " + reskit_pkg_dir + " - is not a directory")

		reskit_files = [f for f in os.listdir(reskit_pkg_dir) if os.path.isfile(os.path.join(reskit_pkg_dir, f))]

		for f in reskit_files:
			print f

	################################################################################

	def reskit(self):
		if self.action == 'update':
			self.reskit_update()
		elif self.action == 'list':
			self.reskit_list()
		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	################################################################################
	################################################################################

	def system_register(self):
		self.is_network_up(exit_if_down=True)

		## work out OS version
		(distname, distversion, distid) = platform.linux_distribution()

		if distid == 'Maipo':
			ident = 'rhel7'
			if self.verbose: print "Detected operating system as RHEL/CentOS 7: " + distname + " " + distversion + " " + distid
		else:
			self.fatal(7,"Your operating system is not supported. Detected as: " + distname + " " + distversion + " " + distid)
			return False

		## Now get the hostname
		register_hostname = platform.node()
		if self.verbose: print "Detected hostname as " + register_hostname

		if not re.match(r"^(uos|iss|lnx|UOS|ISS|LNX)\-[0-9]{2,8}$",register_hostname):
			self.fatal(8,"The hostname of this machine is invalid. It must be of the form uos-<number>")

		register_username = raw_input("Username: ")
		register_password = getpass.getpass()

		register_url = self.config.get('server','address')

		# Ensure trailing slash on the server register URL
		if not register_url.endswith("/"):
			register_url = register_url + "/"

		register_url = register_url + "api/v1/register"

		if self.debug: 
			if self.config.getboolean('server','verify'):
				print "SSL certificate verification enabled"
			else:
				print "SSL certificate verification disabled"

		if self.verbose: print "Registering with API endpoint " + register_url

		try:
			payload = {'ident': ident, 'hostname': register_hostname, 'username': register_username, 'password': register_password}
			r = requests.post(register_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex(8,"Unable to contact registration server",ex)

		if self.debug: print "return code " + str(r.status_code)

		if r.status_code == 200:
			try:
				json = r.json()

				if 'error' in json:
					self.fatal(10,"registration server returned an error: " + json['reason'])

				else:
					if self.verbose: print "Registration server accepted our request"

			except Exception as ex:
				self.fatalex(11,"failed to parse reponse from registration server",ex)

		else:
			self.fatal(12,"unexpected HTTP return code from server: " + str(r.status_code))

		# Save the SSH public key
		if self.debug: print "Saving SSH public key to " + BASE_DIR + "/ssh_public_key"
		try:
			with open(BASE_DIR + '/ssh_public_key', 'w') as f:
				f.write(json['public_key'])
				f.write("\n")
		except Exception as ex:
			self.fatalex(13,"Failed to write to " + BASE_DIR + "/ssh_public_key",ex)

		if self.verbose: print "Saved SSH public key to " + BASE_DIR + "/ssh_public_key"

		# Save the SSH private key
		if self.debug: print "Saving SSH private key to " + BASE_DIR + "/ssh_private_key"
		try:
			with open(BASE_DIR + '/ssh_private_key', 'w') as f:
				f.write(json['private_key'])
		except Exception as ex:
			self.fatalex(14,"Failed to write to " + BASE_DIR + "/ssh_private_key",ex)

		if self.verbose: print "Saved SSH private key to " + BASE_DIR + "/ssh_private_key"

		# Set perms on the key
		if self.debug: print "Setting permissions on " + BASE_DIR + "/ssh_private_key"
		try:
			os.chmod(BASE_DIR + '/ssh_private_key', 0600)
		except Exception as ex:
			self.fatalex(15,"Failed to set the permissions of " + BASE_DIR + "/ssh_private_key",ex)

		if self.verbose: print "Set permissions on " + BASE_DIR + "/ssh_private_key"

		# Save the backup key (for rsyncd)
		if self.debug: print "Saving the backup key to " + BASE_DIR + "/backup_key"
		try:
			with open(BASE_DIR + '/backup_key', 'w') as f:
				f.write("backup:" + json['backup_key'] + "\n")
		except Exception as ex:
			self.fatalex(16,"Failed to write to " + BASE_DIR + "/backup_key",ex)

		if self.verbose: print "Saved backup key to " + BASE_DIR + "/backup_key"

		# Set perms on the key
		if self.debug: print "Setting permissions on " + BASE_DIR + "/backup_key"
		try:
			os.chmod(BASE_DIR + '/backup_key', 0600)

		except Exception as ex:
			self.fatalex(17,"Failed to set the permissions of " + BASE_DIR + "/backup_key",ex)

		if self.verbose: print "Set permissions on " + BASE_DIR + "/backup_key"

		## Merge the new settings into the existing config
		config.set('backup','port',json['backup_port'])
		config.set('server','api_key',json['api_key'])

		if self.debug: print "Saving changes to the drone config file " + BASE_DIR + "/drone.conf"
		try:
			with open(BASE_DIR + '/drone.conf', 'w') as f:
				config.write(f)
		except Exception as ex:
			self.fatalex(18,"Failed to write to " + BASE_DIR + "/drone.conf",ex)

		if self.verbose: print "Saved drone configuration to " + BASE_DIR + "/drone.conf"

		# Set perms on the drone config
		if self.debug: print "Setting permissions on " + BASE_DIR + "/drone.conf"
		try:
			os.chmod(BASE_DIR + '/drone.conf', 0600)
		except Exception as ex:
			self.fatalex(19,"Failed to set the permissions of " + BASE_DIR + "/drone.conf",ex)

		print "Registration completed successfully"

	################################################################################

	def system(self):
		if self.action == 'register':
			self.system_register()
		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	################################################################################

	def version(self):
		print "drone agent v" + VERSION

	################################################################################

	def main(self):
		## We must be root
		if not os.geteuid() == 0:
			self.fatal(1,"You must be root to run this command")

		## Load the config
		self.get_config()

		## Deal with command line arguments
		subcommands = """Available subcommands:

  puppet      manages puppet functions
	status    show the status of the last puppet apply
	sync      download the latest puppet ruleset
	apply     apply puppet policy to the system
	run       performs a 'sync' and then an 'apply'
	facts     show puppet facts about the system

  backup      management of workstation backups
	status    show the status of the last backup
	now       perform a backup of this system
	ifneeded  perform a backup of this system if the last backup attempt
	          was over 12 hours ago. it is intended that you run this 
	          when the system is finished starting up.

  update
	trigger   schedule an offline system update to occur at the next reboot
	history   show the result of the last offline update
	status    show the packages due to be updated (if any) at next reboot

  reskit
	update    update the contents of reskit software packages
	list      list installed reskit software packages

  system
	register  (re-)register this system

  version     shows the version of the drone agent

"""

		self.parser = argparse.ArgumentParser(prog='drone',description='workstation management agent',epilog=subcommands,formatter_class=argparse.RawDescriptionHelpFormatter)
		self.parser.add_argument('subcommand', metavar='subcommand', type=str, help='the function to perform')
		self.parser.add_argument('action', metavar='action', type=str, help='the action to perform', nargs="?", default=None)
		self.parser.add_argument('subaction', metavar='subaction', type=str, help=argparse.SUPPRESS, nargs="?", default=None)
		self.parser.add_argument('-d', '--debug', action='store_true', help='turn on debugging output',dest='debug')
		self.parser.add_argument('-v', '--verbose', action='store_true', help='turn on verbose output',dest='verbose')
		self.parser.add_argument('-i', '--ignore-nm-state', action='store_true', help="don't check with NetworkManager before using the network",dest='nmignore')

		self.args       = self.parser.parse_args()
		self.action     = self.args.action
		self.subcommand = self.args.subcommand
		self.debug      = self.args.debug
		self.verbose    = self.args.verbose

		if self.subcommand == 'puppet':
			self.puppet()
		elif self.subcommand == 'backup':
			self.backup()
		elif self.subcommand == 'update':
			self.update()
		elif self.subcommand == 'reskit':
			self.reskit()
		elif self.subcommand == 'system':
			self.system()
		elif self.subcommand == 'version':
			self.version()
		else:
			print 'Unrecognised subcommand "' + self.subcommand + '"'
			self.parser.print_help()

	################################################################################

if __name__ == "__main__":
	drone = DroneAgent()
	drone.main()
