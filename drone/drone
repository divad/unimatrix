#!/usr/bin/python

CONFIG_FILE = "/etc/soton/drone.conf"
BASE_DIR    = "/etc/soton"
VERSION     = "2017-02-16-05"
ANSI_BOLD   = "\033[1m"
ANSI_RESET  = "\033[0;0m"

import os
import sys
import argparse
import subprocess
import ConfigParser
import datetime
import requests
import re
import platform
import getpass
import time
import json
import yaml
import dmidecode

class DroneAgent:

	############################################################################

	def fatal(self,code,message):
		sys.stderr.write("Error: " + message + "\n")
		sys.exit(code)

	def fatalex(self,code,message,exception):
		sys.stderr.write("Error: " + message + " - " + str(type(exception)) + " " + str(exception) + "\n")
		sys.exit(code)

	############################################################################

	def warn(self,message):
		sys.stderr.write("Warning: " + message + "\n")

	def warnex(self,message,exception):
		sys.stderr.write("Warning: " + message + " - " + str(type(exception)) + " " + str(exception) + "\n")

	############################################################################

	def strtime(self,when=None):
		if when is None:
			dt = datetime.datetime.utcnow()
		else:
			dt = datetime.datetime.utcfromtimestamp(int(when))

		return dt.strftime("%Y-%m-%d %H:%M:%S")

	############################################################################

	def get_config(self):
		self.config = ConfigParser.RawConfigParser()

		## Set up default sections
		self.config.add_section('backup')
		self.config.add_section('puppet')
		self.config.add_section('server')
		self.config.add_section('ssh')
		self.config.add_section('reskit')
		self.config.add_section('csw')
		self.config.add_section('update')
	
		## Set up default values
		self.config.set('backup','user','backup')
		self.config.set('backup','server','localhost')
		self.config.set('backup','rsyncd_port','873')
		self.config.set('backup','port','9999')
		self.config.set('backup','vgname','sysvg')
		self.config.set('backup','lv_source_name','home')
		self.config.set('backup','lv_snap_name','homesnap')
		self.config.set('backup','lv_snap_mount','/mnt/homesnap')

		self.config.set('puppet','user','puppet')
		self.config.set('puppet','binary','/opt/puppetlabs/bin/puppet')
		self.config.set('puppet','server','localhost')

		self.config.set('reskit','pkgdir','/etc/reskit/packages/')
		self.config.set('reskit','server','localhost')
		self.config.set('reskit','share','reskit')

		self.config.set('csw','server','localhost')

		self.config.set('update','pkcon_binary','/bin/pkcon')

		self.config.set('ssh','binary','/usr/bin/ssh')

		self.config.set('server','api_key','unset')

		try:
			self.config.read(CONFIG_FILE)
		except Exception as ex:
			self.fatalex(2,"Could not read the config file " + CONFIG_FILE,ex)

	############################################################################

	def sysexec(self,command,shell=False):
		if self.debug:
			if type(command) is list:
				print "Executing command " + str(" ".join(command))
			else:
				print "Executing command " + str(command)

		try:
			proc = subprocess.Popen(command,stdout=subprocess.PIPE, stderr=subprocess.STDOUT,shell=shell)
			(stdoutdata, stderrdata) = proc.communicate()
			if stdoutdata is None:
				stdoutdata = ""

			if self.debug:
				print "return code: " + str(proc.returncode)
				print "---"
				print stdoutdata
				print "---"
			
			return (proc.returncode,str(stdoutdata))
		except Exception as ex:
			return (1,str(type(ex)) + " " + str(ex))

	############################################################################

	def is_network_up(self,timeout=30,exit_if_down=False):
		if self.args.nmignore:
			if self.debug: print "skipping network test because -i was specified"
			return True

		if self.verbose: print "checking network status"

		(code,output) = self.sysexec(["/usr/bin/nm-online","-q","--timeout=" + str(timeout)])
	
		if code == 0:
			if self.verbose: print "network manager reports the network is up"
			return True
		else:
			if exit_if_down:
				if self.verbose: print "network manager reports the network is down, exiting"
				sys.exit(254)
			else:
				if self.verbose: print "network manager reports the network is down"
				return False

	############################################################################
	############################################################################

	def puppet_sync(self):
		self.is_network_up(exit_if_down=True)

		if self.verbose: print "starting sync"

		(code, output) = self.sysexec("""/usr/bin/rsync -e "ssh -i %s/ssh_private_key -o PreferredAuthentications=publickey -oStrictHostKeyChecking=no" -av --delete %s@%s: %s/puppet/""" % (BASE_DIR, self.config.get('puppet','user'),self.config.get('puppet','server'),BASE_DIR),shell=True)

		if code != 0:
			self.fatal(3,"sync failed: \n" + output)
		else:
			if self.verbose: print "sync complete"

	############################################################################

	def puppet_apply(self):
		if self.verbose: print "starting puppet apply"

		(code, output) = self.sysexec("""%s apply --detailed-exitcodes --modulepath %s/puppet/modules/ %s/puppet/manifests/site.pp""" % (self.config.get('puppet','binary'),BASE_DIR,BASE_DIR),shell=True)

		uts = int(time.time())
		when = "puppet apply last ran at " + self.strtime() + "\n"

		if code == 0:
			status = "system complies with policy, no changes were required"
			if self.verbose: print status
		elif code == 2:
			status = "system complies with policy, changes made to system:"
			status = status + "\n" + output
			if self.verbose: print status

		else:
			status = "apply failed: \n" + output
			self.puppet_save_state(uts,code,output)
			self.fatal(4,status)

		self.puppet_save_state(uts,code,output)

	############################################################################

	def puppet_save_state(self,uts,code,output):
		data = {'when': uts, 'code': code, 'output': output}

		try:
			if not os.path.exists(BASE_DIR + "/state"):
				os.mkdir(BASE_DIR + "/state")
		except Exception as ex:
			self.warn("Could not create directory " + BASE_DIR + "/state - unable to save puppet status")
			return

		try:
			with open(BASE_DIR + "/state/puppet","w") as fp:
				json.dump(data,fp)
		except Exception as ex:
			self.warnex("Could not write to " + BASE_DIR + "/state/puppet",ex)

	############################################################################

	def puppet_get_state(self):
		status_file = BASE_DIR + "/state/puppet" 

		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					data = json.load(fp)
			except Exception as ex:
				self.fatalex(5,"Could not read from puppet status file " + status_file,ex)

			try:
				print "the last puppet apply finished at " + self.strtime(data['when'])

				if data['code'] == 0:
					print "system was in compliance with the system policy"
				elif data['code'] == 2:
					print "changes were made to the system to comply with the system policy:"
					print data['output'].rstrip("\n")
				else:
					print "the attempt to apply the system policy failed:"
					print data['output'].rstrip("\n")

			except Exception as ex:
				self.fatalex(30,"Could not load puppet status",ex)

		else:
			print "puppet apply has never been run on this system"

	############################################################################

	def puppet_facts(self):

		(code, output) = self.sysexec("""%s facts find --modulepath %s/puppet/modules/""" % (self.config.get('puppet','binary'),BASE_DIR),shell=True)

		if code == 0:
			print output
		else:
			self.fatal(27,"Could not retrieve facts: \n" + output)

	############################################################################

	def puppet(self):
		if self.action == 'sync':
			self.puppet_sync()

		elif self.action == "apply":
			self.puppet_apply()

		elif self.action == "run":
			self.puppet_sync()
			self.puppet_apply()

		elif self.action == "status":
			self.puppet_get_state()

		elif self.action == "facts":
			self.puppet_facts()

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################
	############################################################################

	def backup_now(self):
		if not self.is_network_up():
			self.backup_save_state(uts,-2,"The network is down, cannot run backup")
			if self.verbose: print "network is down, not running backup"

		if self.verbose: print "starting backup (this may take several minutes)"

		uts = int(time.time())
		## Ensure the mount point for the snapshot exists
		if self.debug: print "checking config.backup.lv_snap_mount path"
		if not os.path.exists(self.config.get('backup','lv_snap_mount')):
			self.backup_save_state(uts,-1,"The lv_snap_mount directory does not exist")
			self.fatal(20,"The lv_snap_mount directory - " + self.config.get('backup','lv_snap_mount') + " - does not exist")

		## Create the snapshot of home
		if self.debug: print "creating snapshot"
		(code, output) = self.sysexec("""/sbin/lvcreate -n %s -kn -s %s/%s""" % (self.config.get('backup','lv_snap_name'), self.config.get('backup','vgname'), self.config.get('backup','lv_source_name'),),shell=True)

		if code == 0:
			if self.verbose: print "snapshot created"
		else:
			self.backup_save_state(uts,-1,"Could not create disk snapshot: \n" + output)
			self.fatal(21,"Could not create snapshot:\n" + output)

		## Mount it
		if self.debug: print "mounting snapshot"
		(code, output) = self.sysexec("""/bin/mount -o ro,nouuid /dev/mapper/%s-%s %s""" % (self.config.get('backup','vgname'), self.config.get('backup','lv_snap_name'), self.config.get('backup','lv_snap_mount'),),shell=True)

		if code == 0:
			if self.verbose: print "snapshot mounted"
		else:
			self.backup_save_state(uts,-1,"Could not mount disk snapshot: \n" + output)
			self.fatal(21,"Could not mount snapshot:\n" + output)

		## k we're ready! start the backup!
		uts = int(time.time())
		(code, output) = self.sysexec("""%s %s@%s -i %s/ssh_private_key -o "ExitOnForwardFailure yes" -R %s:localhost:%s """ % (self.config.get('ssh','binary'), self.config.get('backup','user'), self.config.get('backup','server'), BASE_DIR, self.config.get('backup','port'),self.config.get('backup','rsyncd_port'),),shell=True)

		fail = False
		if code == 0:
			status = "backup complete, all files backed up"
			self.backup_save_state(uts,code)
		elif code == 1:
			status = "backup partially complete, some files did not backup"
			self.backup_save_state(uts,code)
		else:
			fail = True # we use this later to exit with an error
			status = "backup failed"
			self.backup_save_state(uts,code,output)

		if self.verbose: print status

		if self.debug: print "unmounting snapshot"
		## Now we umount the snapshot and delete it as we don't need it anymore
		(code, output) = self.sysexec("""/bin/umount %s""" % (self.config.get('backup','lv_snap_mount'),),shell=True)

		if code == 0:
			if self.verbose: print "snapshot unmounted"
		else:
			self.fatal(22,"Could not unmount snapshot:\n" + output)

		## Create the snapshot of home
		if self.debug: print "removing snapshot"
		(code, output) = self.sysexec("""/sbin/lvremove -f %s/%s""" % (self.config.get('backup','vgname'), self.config.get('backup','lv_snap_name'),),shell=True)

		if code == 0:
			if self.verbose: print "snapshot removed"
		else:
			self.fatal(23,"Could not delete snapshot:\n" + output)

		# fatal exit if the backup failed
		if fail:
			self.fatal(24,status)

	############################################################################

	def backup_save_state(self,uts,code,output=None):
		data = {'when': uts, 'code': code, 'output': output}

		try:
			if not os.path.exists(BASE_DIR + "/state"):
				os.mkdir(BASE_DIR + "/state")
		except Exception as ex:
			self.warn("Could not create directory " + BASE_DIR + "/state - unable to save backup status")
			return

		try:
			with open(BASE_DIR + "/state/backup","w") as fp:
				json.dump(data,fp)
		except Exception as ex:
			self.warnex("Could not write to " + BASE_DIR + "/state/backup",ex)

	############################################################################

	def backup_load_state(self):
		status_file = BASE_DIR + "/state/backup" 

		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					data = json.load(fp)
			except Exception as ex:
				self.fatalex(5,"Could not read from backup status file " + status_file,ex)

			try:
				code = data['code']
				when = data['when']
				if 'output' in data:
					output = data['output']
				else:
					output = None
			except Exception as ex:
				self.fatalex(29,"Could not load backup status",ex)

		else:
			code   = None
			when   = None
			output = None

		return (code,when,output)

	############################################################################

	def backup_get_state(self):

		(code,when,output) = self.backup_load_state()

		if code is not None:

			print "the last backup attempt was made at " + self.strtime(when)

			if code == 0:
				print "the last backup competed successfully, all files were backed up"
			elif code == 1:
				print "the last backup completed but some files could not be backed up"
			else:
				print "the last backup failed"
				if output is not None:
					print output
		else:
			print "a backup has never been run on this system"

	############################################################################

	def backup_ifneeded(self):
		if self.debug: print "checking for last backup"
		(code,when,output) = self.backup_load_state()

		if code is None:
			if self.verbose: print "no backup status found, triggering backup"
			self.backup_now()
		else:
			last = datetime.datetime.utcfromtimestamp(int(when))

			if (datetime.datetime.utcnow() - last) > datetime.timedelta(hours=12):
				if self.verbose: print "backup is required, triggering backup"
				self.backup_now()
			else:
				if self.verbose: print "backup is not required"

	############################################################################

	def backup(self):
		if self.action == 'now':
			self.backup_now()

		elif self.action == "status":
			self.backup_get_state()

		elif self.action == "ifneeded":
			self.backup_ifneeded()

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################
	############################################################################

	def update_trigger(self):


		if self.verbose: print "downloading package updates"
		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "--only-download", "update"])

		if code == 0:
			if self.verbose: print "package updates downloaded"
		else:
			self.fatal(28,"Could not download package updates:\n" + output)

		if not os.path.exists("/system-update"):
			if self.debug: print "the /system-update trigger is absent"
			if self.verbose: print "triggering offline update"
			(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-trigger"])

			if code == 0:
				if self.verbose: print "the system will update at the next reboot"
			else:
				self.fatal(29,"Could not trigger the offline update:\n" + output)
		else:
			if self.debug: print "the /system-update trigger is already present"
			if self.verbose: print "the system will update at the next reboot"

	############################################################################

	def update_status(self):

		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-get-prepared"])
		print output.rstrip("\n")

	############################################################################

	def update_history(self):

		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-status"])
		print output.rstrip("\n")

	############################################################################

	def update(self):
		if self.action == 'status':
			self.update_status()

		elif self.action == 'history':
			self.update_history()

		elif self.action == "trigger":
			self.update_trigger()

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################
	############################################################################

	def reskit_update_package(self,package):
		if self.verbose: print "starting update of '" + package + "'"

		reskit_pkgdir  = self.config.get('reskit','pkgdir')
		reskit_server  = self.config.get('reskit','server')
		reskit_share   = self.config.get('reskit','share')

		package_file = os.path.join(reskit_pkgdir,package)

		## Open the reskit package file
		## this is a yaml formatted file with
		## two variables - source and dest (for rsync)
		try:
			if self.debug: print "opening file '" + package_file + "'"
			with open(package_file,"r") as fp:
				package_data = yaml.safe_load(fp)
		except Exception as ex:
			if self.verbose: self.warnex("Could not read package metadata from '" + package_file + "'",ex)
			return

		try:
			package_source = package_data['src']
			package_dest   = package_data['dest']
		except Exception as ex:
			if self.verbose: self.warnex("Invalid/incorrect metadata in '" + package_file + "'",ex)
			return

		(code, output) = self.sysexec("""/usr/bin/rsync -av --delete rsync://%s/%s/%s %s""" % (reskit_server, reskit_share, package_source, package_dest,),shell=True)

		if code != 0:
			if self.verbose: print "reskit update of '" + package + "' failed: \n" + output 
		else:
			if self.verbose: print "reskit update of '" + package + "' complete"

	############################################################################

	def reskit_update(self):
		self.is_network_up(exit_if_down=True)

		if self.verbose: print "starting reskit update (this may take several minutes)"

		reskit_pkg_dir = self.config.get('reskit','pkgdir')

		if self.debug: print "checking config.reskit.pkgdir"
		if not os.path.exists(reskit_pkg_dir):
			self.fatal(25,"The reskit pkgdir directory - " + reskit_pkg_dir + " - does not exist")
		if not os.path.isdir(reskit_pkg_dir):
			self.fatal(26,"The reskit pkgdir path - " + reskit_pkg_dir + " - is not a directory")

		reskit_files = [f for f in os.listdir(reskit_pkg_dir) if os.path.isfile(os.path.join(reskit_pkg_dir, f))]

		package_name = self.args.subaction
		if package_name is None:
			for f in reskit_files:
				try:
					self.reskit_update_package(f)
				except Exception as ex:
					if self.verbose: self.warnex("Failed to run reskit update on " + f,ex)
		else:
			if self.debug: print "user asked to update specific package '" + package_name + "'"

			if package_name in reskit_files:
				self.reskit_update_package(package_name)
			else:
				self.fatal(31,"Package '" + package_name + "' not found")

		if self.verbose: print "reskit update complete"

	############################################################################

	def reskit_list(self):
		reskit_pkg_dir = self.config.get('reskit','pkgdir')

		if self.debug: print "checking config.reskit.pkgdir"
		if not os.path.exists(reskit_pkg_dir):
			self.fatal(25,"The reskit pkgdir directory - " + reskit_pkg_dir + " - does not exist")
		if not os.path.isdir(reskit_pkg_dir):
			self.fatal(26,"The reskit pkgdir path - " + reskit_pkg_dir + " - is not a directory")

		reskit_files = [f for f in os.listdir(reskit_pkg_dir) if os.path.isfile(os.path.join(reskit_pkg_dir, f))]

		for f in reskit_files:
			print f

	############################################################################

	def reskit(self):
		if self.action == 'update':
			self.reskit_update()
		elif self.action == 'list':
			self.reskit_list()
		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################
	############################################################################

	def system_register(self):
		self.is_network_up(exit_if_down=True)

		## work out OS version
		(distname, distversion, distid) = platform.linux_distribution()

		if distid == 'Maipo':
			ident = 'rhel7'
			if self.verbose: print "Detected operating system as RHEL/CentOS 7: " + distname + " " + distversion + " " + distid
		else:
			self.fatal(7,"Your operating system is not supported. Detected as: " + distname + " " + distversion + " " + distid)
			return False

		## Now get the hostname
		register_hostname = platform.node()
		if self.verbose: print "Detected hostname as " + register_hostname

		if not re.match(r"^(uos|iss|lnx|UOS|ISS|LNX)\-[0-9]{2,8}$",register_hostname):
			self.fatal(8,"The hostname of this machine is invalid. It must be of the form uos-<number>")

		register_username = raw_input("Username: ")
		register_password = getpass.getpass()

		register_url = self.config.get('server','address')

		# Ensure trailing slash on the server register URL
		if not register_url.endswith("/"):
			register_url = register_url + "/"

		register_url = register_url + "api/v1/register"

		if self.debug: 
			if self.config.getboolean('server','verify'):
				print "SSL certificate verification enabled"
			else:
				print "SSL certificate verification disabled"

		if self.verbose: print "Registering with API endpoint " + register_url

		try:
			payload = {'ident': ident, 'hostname': register_hostname, 'username': register_username, 'password': register_password}
			r = requests.post(register_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex(8,"Unable to contact registration server",ex)

		if self.debug: print "return code " + str(r.status_code)

		if r.status_code == 200:
			try:
				json = r.json()

				if 'error' in json:
					self.fatal(10,"registration server returned an error: " + json['reason'])

				else:
					if self.verbose: print "Registration server accepted our request"

			except Exception as ex:
				self.fatalex(11,"failed to parse reponse from registration server",ex)

		else:
			self.fatal(12,"unexpected HTTP return code from server: " + str(r.status_code))

		# Save the SSH public key
		if self.debug: print "Saving SSH public key to " + BASE_DIR + "/ssh_public_key"
		try:
			with open(BASE_DIR + '/ssh_public_key', 'w') as f:
				f.write(json['public_key'])
				f.write("\n")
		except Exception as ex:
			self.fatalex(13,"Failed to write to " + BASE_DIR + "/ssh_public_key",ex)

		if self.verbose: print "Saved SSH public key to " + BASE_DIR + "/ssh_public_key"

		# Save the SSH private key
		if self.debug: print "Saving SSH private key to " + BASE_DIR + "/ssh_private_key"
		try:
			with open(BASE_DIR + '/ssh_private_key', 'w') as f:
				f.write(json['private_key'])
		except Exception as ex:
			self.fatalex(14,"Failed to write to " + BASE_DIR + "/ssh_private_key",ex)

		if self.verbose: print "Saved SSH private key to " + BASE_DIR + "/ssh_private_key"

		# Set perms on the key
		if self.debug: print "Setting permissions on " + BASE_DIR + "/ssh_private_key"
		try:
			os.chmod(BASE_DIR + '/ssh_private_key', 0600)
		except Exception as ex:
			self.fatalex(15,"Failed to set the permissions of " + BASE_DIR + "/ssh_private_key",ex)

		if self.verbose: print "Set permissions on " + BASE_DIR + "/ssh_private_key"

		# Save the backup key (for rsyncd)
		if self.debug: print "Saving the backup key to " + BASE_DIR + "/backup_key"
		try:
			with open(BASE_DIR + '/backup_key', 'w') as f:
				f.write("backup:" + json['backup_key'] + "\n")
		except Exception as ex:
			self.fatalex(16,"Failed to write to " + BASE_DIR + "/backup_key",ex)

		if self.verbose: print "Saved backup key to " + BASE_DIR + "/backup_key"

		# Set perms on the key
		if self.debug: print "Setting permissions on " + BASE_DIR + "/backup_key"
		try:
			os.chmod(BASE_DIR + '/backup_key', 0600)

		except Exception as ex:
			self.fatalex(17,"Failed to set the permissions of " + BASE_DIR + "/backup_key",ex)

		if self.verbose: print "Set permissions on " + BASE_DIR + "/backup_key"

		## Merge the new settings into the existing config
		self.config.set('backup','port',json['backup_port'])
		self.config.set('server','api_key',json['api_key'])

		if self.debug: print "Saving changes to the drone config file " + BASE_DIR + "/drone.conf"
		try:
			with open(BASE_DIR + '/drone.conf', 'w') as f:
				self.config.write(f)
		except Exception as ex:
			self.fatalex(18,"Failed to write to " + BASE_DIR + "/drone.conf",ex)

		if self.verbose: print "Saved drone configuration to " + BASE_DIR + "/drone.conf"

		# Set perms on the drone config
		if self.debug: print "Setting permissions on " + BASE_DIR + "/drone.conf"
		try:
			os.chmod(BASE_DIR + '/drone.conf', 0600)
		except Exception as ex:
			self.fatalex(19,"Failed to set the permissions of " + BASE_DIR + "/drone.conf",ex)

		print "Registration completed successfully"

	############################################################################

	def system_status(self):
		print ANSI_BOLD + "backup status:" + ANSI_RESET
		self.backup_get_state()
		print ANSI_BOLD + "\npuppet status:" + ANSI_RESET
		self.puppet_get_state()
		print ANSI_BOLD + "\nupdate status:" + ANSI_RESET
		self.update_status()

	############################################################################
	
	def system_get_gpu(self):
		# NOTE this assumes just one VGA card is visible in lspci, and thus
		# outputs the first one in the list. Its VERY rare that a system would
		# have /two/ graphics cards the OS can utilise.

		try:
			re_vga = re.compile(r'^[0-9a-f]+:[0-9a-f]+\.[0-9a-f]+\s+VGA\s+compatible\s+controller:\s+(.*)')

			(code,output) = self.sysexec(['/usr/sbin/lspci'])
		
			cards = []
			for line in output.splitlines():
				vga_match = re_vga.search(line)
				if vga_match is not None:
					cards.append(vga_match.group(1))

			if len(cards) >= 0:
				return cards[0]
			else:
				return "No GPU found"
		except Exception as ex:
			return "Could not determine GPU"

	############################################################################

	def system_get_mem(self):
		try:
			total = 0
			for mem in dmidecode.memory().values():
				if 'Form Factor' in mem['data']:
					if mem['data']['Form Factor'] in ['DIMM','SODIMM']:
						if 'Size' in mem['data'] and mem['data']['Size'] is not None:
							parts = mem['data']['Size'].split(' ')
							number = parts[0]
							unit = parts[1]

							# Store size in bytes
							if unit == 'KB' or unit == 'KiB':
								size = int(number) * 1024
							elif unit == 'MB' or unit == 'MiB':
								size = int(number) * 1048576
							elif unit == 'GB' or unit == 'GiB':
								size = int(number) * 1073741824
							elif unit == 'TB' or unit == 'TiB':
								size = int(number) * 1099511627776
							else:
								size = int(number)

							total = total + size

			human = str(total) + " bytes"
			if total > 1073741824:
				human = str(total / 1024 / 1024 / 1024) + " GB"
			elif total > 1048576:
				human = str(total / 1024 / 1024) + " MB"
			elif total > 1024:
				human = str(total / 1024) + " KB"

			return (total,human)
		except Exception as ex:
			return (0,"Could not determine physical memory")

	############################################################################

	def system_get_cpu(self):
		try:

			re_processor = re.compile(r'^processor\s*:\s+([0-9]+)')
			re_physical_id = re.compile(r'^physical\sid\s*:\s+([0-9]+)')
			re_cpu_cores = re.compile(r'^cpu\scores\s*:\s+([0-9]+)')
			re_model_name = re.compile(r'^model\sname\s*:\s+(.*)')
			re_cache_size = re.compile(r'^cache\ssize\s*:\s+(.*)')

			# Setup
			processor = None
			cpu = None
			cpu_cores = None
			model = None
			cache_size = None
			procs = {}

			# Read the entire cpuinfo file
			cpuinfo = open('/proc/cpuinfo', 'r')
			for line in cpuinfo:
				# Match the line against our regexs
				p_match     = re_processor.search(line)
				pid_match   = re_physical_id.search(line)
				cpu_match   = re_cpu_cores.search(line)
				model_match = re_model_name.search(line)
				cache_match = re_cache_size.search(line)

				if p_match is not None:
					# We're starting a new CPU, record the old one
					if cpu is not None and cpu not in procs:
						procs[cpu] = { 'model': model, 'cores': cpu_cores, 'cache': cache_size }
				
					#processor = int(p_match.group(1))
					cpu = None
					cpu_core = None
					model = None

				if pid_match is not None:
					cpu = int(pid_match.group(1))

				if cpu_match is not None:
					cpu_cores = int(cpu_match.group(1))

				if model_match is not None:
					model = model_match.group(1)

				if cache_match is not None:
					cache_size = cache_match.group(1)

			# Pick up the last CPU
			if cpu is not None and cpu not in procs:
				procs[cpu] = { 'model': model, 'cores': cpu_cores, 'cache': cache_size }

			if len(procs) > 0:
				cpu = str(len(procs)) + "x "
	
				if procs[0]['cores'] == 1:
					cpu = cpu + "single-core "
				elif procs[0]['cores'] == 2:
					cpu = cpu + "dual-core "
				elif procs[0]['cores'] == 4:
					cpu = cpu + "quad-core "
				elif procs[0]['cores'] == 8:
					cpu = cpu + "octa-core "
				else:
					cpu = cpu + str(procs[0]['cores']) + "-core "

				return cpu + procs[0]['model']

			else:
				return "Unknown CPU"

		except Exception as ex:
			return "Could not determine CPU information"

	############################################################################

	def system_get_sys(self):
		try:
			system_values = dmidecode.system().values()
		except Exception as ex:
			system_values = []

		vendor = ""
		try:
			for entry in system_values:
				if 'data' in entry:
					if 'Manufacturer' in entry['data']:
						vendor = entry['data']['Manufacturer']
						break
		except Exception as ex:
			pass

		model = ""
		try:
			for entry in system_values:
				if 'data' in entry:
					if 'Product Name' in entry['data']:
						model = entry['data']['Product Name']
						break
		except Exception as ex:
			pass

		return vendor + " " + model

	############################################################################

	def system_hwinfo(self):
		cpu = self.system_get_cpu()
		(memt,mem) = self.system_get_mem()
		gpu = self.system_get_gpu()
		sys = self.system_get_sys()

		print ANSI_BOLD + "SYS: " + ANSI_RESET + sys
		print ANSI_BOLD + "CPU: " + ANSI_RESET + cpu
		print ANSI_BOLD + "MEM: " + ANSI_RESET + mem
		print ANSI_BOLD + "GPU: " + ANSI_RESET + gpu

	############################################################################

	def system(self):
		if self.action == 'register':
			self.system_register()
		elif self.action == 'status':
			self.system_status()
		elif self.action == 'hwinfo':
			self.system_hwinfo()
		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################

	def ldi_event(self,hostname,api_key,server_url,event):
		server_url = server_url + "api/v1/event"

		if self.debug: print "POSTing to " + server_url + " with hostname " + hostname
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'event': event}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex(8,"Unable to contact LDI server",ex)

		if self.debug: print "return code " + str(r.status_code)

		if r.status_code == 200:
			if self.verbose: print "LDI server acknowleged the event"
		else:
			self.fatal(12,"unexpected HTTP return code from server: " + str(r.status_code))

	############################################################################

	def ldi_status(self,hostname,api_key,server_url):
		server_url = server_url + "api/v1/update/status"

		status_file = BASE_DIR + "/state/puppet"
		if self.debug: print "Opening " + status_file
		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					puppet_status = fp.read()
			except Exception as ex:
				self.fatalex(5,"Could not read from puppet status file " + status_file,ex)

		if self.debug: print "POSTing to " + server_url + " with hostname " + hostname
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'type': 'puppet', 'data': puppet_status}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex(8,"Unable to contact LDI server",ex)

		if self.debug: print "return code " + str(r.status_code)

		if r.status_code == 200:
			if self.verbose: print "LDI server accepted the puppet status update"
		else:
			self.fatal(12,"unexpected HTTP return code from server: " + str(r.status_code))

		status_file = BASE_DIR + "/state/backup" 
		if self.debug: print "Opening " + status_file
		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					backup_status = fp.read()
			except Exception as ex:
				self.fatalex(5,"Could not read from backup status file " + status_file,ex)

		if self.debug: print "POSTing to " + server_url + " with hostname " + hostname
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'type': 'backup', 'data': backup_status}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex(8,"Unable to contact LDI server",ex)

		if self.debug: print "return code " + str(r.status_code)

		if r.status_code == 200:
			if self.verbose: print "LDI server accepted the backup status update"
		else:
			self.fatal(12,"unexpected HTTP return code from server: " + str(r.status_code))

		## the update status is quite different. at the moment we just send 
		## back a json document just like the above two, but we just set the 
		## code output of the 'pkcon offline-get-prepared' command
		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-get-prepared"])

		update_status = '{ "offline-get-prepared": ' + str(code) + '}'

		if self.debug: print "POSTing to " + server_url + " with hostname " + hostname
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'type': 'update', 'data': update_status}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex(8,"Unable to contact LDI server",ex)

		if self.debug: print "return code " + str(r.status_code)

		if r.status_code == 200:
			if self.verbose: print "LDI server accepted the software update status update"
		else:
			self.fatal(12,"unexpected HTTP return code from server: " + str(r.status_code))

	############################################################################

	def ldi_metadata(self,hostname,api_key,server_url):
		"""metadata is a series of custom-generated bits of data about the 
		workstation that are not exposed via Puppet facts. True, we could write
		custom facts, but they would have to be in Ruby. Eww."""

		server_url = server_url + "api/v1/update/metadata"

		metadata = {}

		gpu = self.system_get_gpu()
		sys = self.system_get_sys()

		metadata['hwinfo.cpu'] = self.system_get_cpu()
		(memt,metadata['hwinfo.mem']) = self.system_get_mem()
		metadata['hwinfo.gpu'] = self.system_get_gpu()
		metadata['hwinfo.sys'] = self.system_get_sys()
		metadata['drone.version'] = VERSION

		metadata = json.dumps(metadata)

		if self.debug: print "POSTing to " + server_url + " with hostname " + hostname
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'metadata': metadata}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex(8,"Unable to contact LDI server",ex)

		if self.debug: print "return code " + str(r.status_code)

		if r.status_code == 200:
			if self.verbose: print "LDI server accepted the metadata update"
		else:
			self.fatal(12,"unexpected HTTP return code from server: " + str(r.status_code))

	############################################################################

	def ldi_facts(self,hostname,api_key,server_url):
		server_url = server_url + "api/v1/update/facts"

		(code, output) = self.sysexec("""%s facts find --render-as json --modulepath %s/puppet/modules/""" % (self.config.get('puppet','binary'),BASE_DIR),shell=True)

		if code != 0:
			self.fatal(27,"Could not retrieve facts: \n" + output)

		if self.debug: print "POSTing to " + server_url + " with hostname " + hostname
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'facts': output}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex(8,"Unable to contact LDI server",ex)

		if self.debug: print "return code " + str(r.status_code)

		if r.status_code == 200:
			if self.verbose: print "LDI server accepted the facts update"
		else:
			self.fatal(12,"unexpected HTTP return code from server: " + str(r.status_code))

	############################################################################

	def ldi(self):
		hostname = platform.node()
		api_key = self.config.get('server','api_key')

		server_url = self.config.get('server','address')
		if not server_url.endswith("/"):
			server_url = server_url + "/"

		if self.action in ['startup','shutdown','ping']:
			self.ldi_event(hostname,api_key,server_url,self.action)

		elif self.action == 'status':
			self.ldi_status(hostname,api_key,server_url)

		elif self.action == 'metadata':
			self.ldi_metadata(hostname,api_key,server_url)

		elif self.action == 'facts':
			self.ldi_facts(hostname,api_key,server_url)

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################

	def version(self):
		print "drone agent v" + VERSION

	############################################################################

	def main(self):
		## We must be root
		if not os.geteuid() == 0:
			self.fatal(1,"You must be root to run this command")

		## Load the config
		self.get_config()

		## Deal with command line arguments
		functions = """Available functions/actions:

  puppet
    status    show the status of the last puppet apply
    sync      download the latest puppet ruleset
    apply     apply puppet policy to the system
    run       performs a 'sync' and then an 'apply'
    facts     show puppet facts about the system

  backup
    now       perform a backup of this system
    status    show the status of the last backup
    ifneeded  perform a backup of this system if the last backup attempt
              was over 12 hours ago. it is intended that you run this 
              when the system is finished starting up.

  update
    trigger   schedule an offline system update to occur at the next reboot
    history   show the result of the last offline update
    status    show the packages due to be updated (if any) at next reboot

  reskit
    update    update the contents of reskit software packages
    list      list installed reskit software packages

  system
    register  (re-)register this system
    status    shows the system backup, puppet and update status
    hwinfo    shows the hardware information of the system

  ldi
    startup   inform the LDI server that the system has just started up
    shutdown  inform the LDI server that the system is shutting down
    ping      inform the LDI server that the system is alive
    status    inform the LDI server of the system status
    metadata  inform the LDI server about the system hardware
    facts     inform the LDI server of our puppet facts

  version     shows the version of the drone agent
  status      an alias for 'drone system status'

"""

		self.parser = argparse.ArgumentParser(prog='drone',description='workstation management agent',epilog=functions,formatter_class=argparse.RawDescriptionHelpFormatter)
		self.parser.add_argument('function', metavar='function', type=str, help='the function to perform')
		self.parser.add_argument('action', metavar='action', type=str, help='the action to perform', nargs="?", default=None)
		self.parser.add_argument('subaction', metavar='subaction', type=str, help=argparse.SUPPRESS, nargs="?", default=None)
		self.parser.add_argument('-d', '--debug', action='store_true', help='turn on debugging output',dest='debug')
		self.parser.add_argument('-v', '--verbose', action='store_true', help='turn on verbose output',dest='verbose')
		self.parser.add_argument('-i', '--ignore-nm-state', action='store_true', help="don't check with NetworkManager before using the network",dest='nmignore')

		self.args       = self.parser.parse_args()
		self.action     = self.args.action
		self.function   = self.args.function
		self.debug      = self.args.debug
		self.verbose    = self.args.verbose

		if self.function == 'puppet':
			self.puppet()
		elif self.function == 'backup':
			self.backup()
		elif self.function == 'update':
			self.update()
		elif self.function == 'reskit':
			self.reskit()
		elif self.function == 'system':
			self.system()
		elif self.function == 'ldi':
			self.ldi()
		elif self.function == 'version':
			self.version()
		elif self.function == 'help':
			self.parser.print_help()
		elif self.function == 'status':
			self.system_status()
		else:
			print 'Unrecognised function "' + self.function + '"'
			self.parser.print_help()

	############################################################################

if __name__ == "__main__":
	drone = DroneAgent()
	drone.main()
